'use client';

import { useState } from 'react';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Button } from './ui/button';
import { ArrowLeft, Link as LinkIcon, Plus, Trash2, Wand2 } from 'lucide-react';
import { Label } from './ui/label';
import { Textarea } from './ui/textarea';
import { useToast } from '@/hooks/use-toast';
import { ScriptDisplay } from './script-display';

type SourceManagerProps = {
  selectedTitle: string;
  onBack: () => void;
};

// A mock script data structure for demonstration purposes.
// In a real application, this would be generated by an AI flow.
export type ScriptData = {
  topic: string;
  script: string;
  takeaways: string[];
  references: string[];
};

const mockScriptData: ScriptData = {
    topic: "The Future of Azure Hybrid Cloud",
    script: `
# Introduction
Welcome back to AzurePod AI, the podcast where we dive deep into the world of Microsoft Azure. Today, we're tackling a massive topic: the future of Azure Hybrid Cloud. What does it mean to be truly hybrid, and where is Microsoft taking us?

# The Core of Azure Hybrid: Azure Arc
At the heart of Microsoft's hybrid strategy is Azure Arc. It's not just about connecting your on-premises servers to Azure anymore. Arc extends the Azure control plane—the management, governance, and services—to any infrastructure. This means you can manage your Windows and Linux servers, Kubernetes clusters, and even data services running on-premises, at the edge, or even in other clouds like AWS and GCP, right from the Azure portal.

---
Callout: Think about that for a second. You can apply Azure policies, use Azure Monitor, and deploy Azure data services to a server sitting in a competitor's cloud. That's a huge paradigm shift. It moves from "cloud vs. on-prem" to "Azure as your universal control plane."
---

# Real-World Scenario: Retail Edge Computing
Imagine a large retail chain with thousands of stores. Each store has local servers running inventory management and point-of-sale systems. With Azure Arc, the central IT team can manage all of these distributed servers as if they were Azure resources. They can deploy containerized applications to Kubernetes clusters in each store using GitOps, monitor their health with Azure Monitor, and ensure security compliance with Microsoft Defender for Cloud, all from a single dashboard.

# What's Next? AI at the Edge
The next frontier is bringing AI to the edge. With services like Azure Machine Learning and Azure IoT, combined with Arc-enabled infrastructure, you can train models in the cloud and deploy them to the edge for real-time inference. This is critical for scenarios like video analytics in a smart factory or real-time fraud detection in a financial institution, where latency is a major concern. The future is about processing data where it's generated, and Azure's hybrid capabilities are making that a reality.

# Conclusion
So, the future of Azure Hybrid isn't just a bridge between your datacenter and the cloud. It's about creating a single, unified platform for management, security, and application deployment, no matter where your resources live. It's an ambitious vision, but with tools like Azure Arc, it's a vision that's rapidly becoming a reality. Thanks for tuning in!
`,
    takeaways: [
        "Azure Arc is the core of Microsoft's hybrid strategy, extending the Azure control plane to any infrastructure.",
        "Hybrid cloud is no longer just about connecting on-prem to the cloud; it's about a universal management plane.",
        "Real-world applications include centralized management for retail edge computing and deploying AI models for real-time inference at the edge.",
        "The future involves processing data where it is generated, reducing latency and improving efficiency."
    ],
    references: [
        "https://azure.microsoft.com/en-us/products/azure-arc",
        "https://learn.microsoft.com/en-us/azure/azure-arc/overview"
    ]
};


export function SourceManager({ selectedTitle, onBack }: SourceManagerProps) {
  const [sources, setSources] = useState<string[]>([]);
  const [urls, setUrls] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [scriptData, setScriptData] = useState<ScriptData | null>(null);

  const { toast } = useToast();

  const handleAddSources = () => {
    const urlArray = urls
      .split('\n')
      .map((url) => url.trim())
      .filter((url) => {
        try {
          new URL(url);
          return true;
        } catch {
          return false;
        }
      });

    if (urlArray.length === 0) {
      toast({
        title: 'Invalid URLs',
        description: 'Please enter at least one valid URL.',
        variant: 'destructive',
      });
      return;
    }

    const newSources = urlArray.filter((url) => !sources.includes(url));
    setSources([...sources, ...newSources]);
    setUrls('');
  };

  const handleRemoveSource = (urlToRemove: string) => {
    setSources(sources.filter((url) => url !== urlToRemove));
  };
  
  const handleGenerateScript = async () => {
    if (sources.length === 0) {
        toast({
            title: 'No sources provided',
            description: 'Please add at least one source URL to generate the script.',
            variant: 'destructive'
        });
        return;
    }
    
    setIsLoading(true);
    // TODO: Replace this mock with a real Genkit flow call
    setTimeout(() => {
        const dataWithSources = { ...mockScriptData, references: sources, topic: selectedTitle };
        setScriptData(dataWithSources);
        setIsLoading(false);
    }, 1500);
  }
  
  if (scriptData) {
      return <ScriptDisplay scriptData={scriptData} />;
  }

  return (
    <Card className="shadow-lg">
      <CardHeader>
        <div className="flex items-center gap-4">
          <Button
            variant="outline"
            size="icon"
            onClick={onBack}
            className="shrink-0"
          >
            <ArrowLeft className="h-4 w-4" />
            <span className="sr-only">Back</span>
          </Button>
          <div>
            <CardTitle className="font-headline text-3xl">
              Add Sources
            </CardTitle>
            <CardDescription>
              Provide sources for the title: "{selectedTitle}"
            </CardDescription>
          </div>
        </div>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="space-y-2">
          <Label htmlFor="urls" className="text-lg font-semibold font-headline">
            Source URLs
          </Label>
          <Textarea
            id="urls"
            placeholder="https://docs.microsoft.com/...\nhttps://azure.microsoft.com/en-us/blog/..."
            value={urls}
            onChange={(e) => setUrls(e.target.value)}
            rows={4}
            disabled={isLoading}
          />
        </div>
        <Button onClick={handleAddSources} disabled={isLoading}>
          <Plus className="mr-2" /> Add Sources
        </Button>

        {sources.length > 0 && (
          <div>
            <h3 className="font-headline text-xl font-semibold mb-3">
              Added Sources
            </h3>
            <ul className="space-y-2">
              {sources.map((url, index) => (
                <li
                  key={index}
                  className="flex items-center justify-between p-3 rounded-md border bg-muted/50"
                >
                  <div className="flex items-center gap-3 truncate">
                    <LinkIcon className="h-4 w-4 text-muted-foreground shrink-0" />
                    <span className="truncate text-sm text-foreground/90">
                      {url}
                    </span>
                  </div>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => handleRemoveSource(url)}
                    className="shrink-0 h-8 w-8"
                    aria-label="Remove source"
                    disabled={isLoading}
                  >
                    <Trash2 className="h-4 w-4 text-destructive" />
                  </Button>
                </li>
              ))}
            </ul>
          </div>
        )}
      </CardContent>
      <CardFooter className="flex justify-end bg-muted/50 p-4 rounded-b-lg">
        <Button onClick={handleGenerateScript} disabled={isLoading || sources.length === 0}>
            {isLoading ? (
                <>
                    <Wand2 className="mr-2 h-5 w-5 animate-spin" />
                    Generating Script...
                </>
            ) : (
                <>
                    <Wand2 className="mr-2 h-5 w-5" />
                    Generate Script
                </>
            )}
        </Button>
      </CardFooter>
    </Card>
  );
}
