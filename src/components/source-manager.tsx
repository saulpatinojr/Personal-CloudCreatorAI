'use client';

import * as React from 'react';
import { useState } from 'react';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Button } from './ui/button';
import { ArrowLeft, FileText, Link as LinkIcon, Plus, Text, Trash2, Wand2 } from 'lucide-react';
import { Label } from './ui/label';
import { Textarea } from './ui/textarea';
import { useToast } from '@/hooks/use-toast';
import { ScriptDisplay } from './script-display';

type SourceManagerProps = {
  selectedTitle: string;
  onBack: () => void;
};

// A mock script data structure for demonstration purposes.
// In a real application, this would be generated by an AI flow.
export type ScriptData = {
  topic: string;
  script: string;
  takeaways: string[];
  references: string[];
};

const mockScriptData: ScriptData = {
    topic: "The Future of Azure Hybrid Cloud",
    script: `
# Introduction
Welcome back to AzurePod AI, the podcast where we dive deep into the world of Microsoft Azure. Today, we're tackling a massive topic: the future of Azure Hybrid Cloud. What does it mean to be truly hybrid, and where is Microsoft taking us?

# The Core of Azure Hybrid: Azure Arc
At the heart of Microsoft's hybrid strategy is Azure Arc. It's not just about connecting your on-premises servers to Azure anymore. Arc extends the Azure control plane—the management, governance, and services—to any infrastructure. This means you can manage your Windows and Linux servers, Kubernetes clusters, and even data services running on-premises, at the edge, or even in other clouds like AWS and GCP, right from the Azure portal.

---
Callout: Think about that for a second. You can apply Azure policies, use Azure Monitor, and deploy Azure data services to a server sitting in a competitor's cloud. That's a huge paradigm shift. It moves from "cloud vs. on-prem" to "Azure as your universal control plane."
---

# Real-World Scenario: Retail Edge Computing
Imagine a large retail chain with thousands of stores. Each store has local servers running inventory management and point-of-sale systems. With Azure Arc, the central IT team can manage all of these distributed servers as if they were Azure resources. They can deploy containerized applications to Kubernetes clusters in each store using GitOps, monitor their health with Azure Monitor, and ensure security compliance with Microsoft Defender for Cloud, all from a single dashboard.

# What's Next? AI at the Edge
The next frontier is bringing AI to the edge. With services like Azure Machine Learning and Azure IoT, combined with Arc-enabled infrastructure, you can train models in the cloud and deploy them to the edge for real-time inference. This is critical for scenarios like video analytics in a smart factory or real-time fraud detection in a financial institution, where latency is a major concern. The future is about processing data where it's generated, and Azure's hybrid capabilities are making that a reality.

# Conclusion
So, the future of Azure Hybrid isn't just a bridge between your datacenter and the cloud. It's about creating a single, unified platform for management, security, and application deployment, no matter where your resources live. It's an ambitious vision, but with tools like Azure Arc, it's a vision that's rapidly becoming a reality. Thanks for tuning in!
`,
    takeaways: [
        "Azure Arc is the core of Microsoft's hybrid strategy, extending the Azure control plane to any infrastructure.",
        "Hybrid cloud is no longer just about connecting on-prem to the cloud; it's about a universal management plane.",
        "Real-world applications include centralized management for retail edge computing and deploying AI models for real-time inference at the edge.",
        "The future involves processing data where it is generated, reducing latency and improving efficiency."
    ],
    references: [
        "https://azure.microsoft.com/en-us/products/azure-arc",
        "https://learn.microsoft.com/en-us/azure/azure-arc/overview"
    ]
};

type Source = {
  id: string;
  type: 'url' | 'pdf' | 'text';
  name: string;
  content: string;
};

export function SourceManager({ selectedTitle, onBack }: SourceManagerProps) {
  const [sources, setSources] = useState<Source[]>([]);
  const [urls, setUrls] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [scriptData, setScriptData] = useState<ScriptData | null>(null);

  const { toast } = useToast();
  const fileInputRef = React.useRef<HTMLInputElement>(null);

  const handleAddUrls = () => {
    const urlArray = urls
      .split('\n')
      .map((url) => url.trim())
      .filter((url) => {
        try {
          new URL(url);
          return true;
        } catch {
          return false;
        }
      });

    if (urlArray.length === 0 && urls.trim() !== '') {
      toast({
        title: 'Invalid URLs',
        description: 'Please enter at least one valid URL.',
        variant: 'destructive',
      });
      return;
    }

    const newSources = urlArray
      .filter((url) => !sources.some(s => s.type === 'url' && s.content === url))
      .map(url => ({
        id: crypto.randomUUID(),
        type: 'url' as const,
        name: url,
        content: url
      }));

    setSources([...sources, ...newSources]);
    setUrls('');
  };

  const handleAddText = () => {
    const textContent = prompt("Paste your text content here:");
    if (textContent && textContent.trim()) {
      const newSource: Source = {
        id: crypto.randomUUID(),
        type: 'text',
        name: `Text Snippet (${textContent.substring(0, 20)}...)`,
        content: textContent,
      };
      setSources([...sources, newSource]);
    }
  };

  const handlePdfUploadClick = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file && file.type === 'application/pdf') {
      const newSource: Source = {
        id: crypto.randomUUID(),
        type: 'pdf',
        name: file.name,
        // In a real app, you'd process the file here (e.g., upload and get a URL)
        content: file.name,
      };
      setSources([...sources, newSource]);
    } else if (file) {
      toast({
        title: 'Invalid File Type',
        description: 'Please select a PDF file.',
        variant: 'destructive',
      });
    }
    // Reset file input
    if(event.target) event.target.value = '';
  };

  const handleRemoveSource = (idToRemove: string) => {
    setSources(sources.filter((source) => source.id !== idToRemove));
  };
  
  const handleGenerateScript = async () => {
    if (sources.length === 0) {
        toast({
            title: 'No sources provided',
            description: 'Please add at least one source URL to generate the script.',
            variant: 'destructive'
        });
        return;
    }
    
    setIsLoading(true);
    // TODO: Replace this mock with a real Genkit flow call that uses the sources
    setTimeout(() => {
        const dataWithSources = { ...mockScriptData, references: sources.map(s => s.name), topic: selectedTitle };
        setScriptData(dataWithSources);
        setIsLoading(false);
    }, 1500);
  }
  
  const renderSourceIcon = (type: Source['type']) => {
    switch (type) {
        case 'url': return <LinkIcon className="h-4 w-4 text-muted-foreground shrink-0" />;
        case 'pdf': return <FileText className="h-4 w-4 text-muted-foreground shrink-0" />;
        case 'text': return <Text className="h-4 w-4 text-muted-foreground shrink-0" />;
        default: return null;
    }
  }
  
  if (scriptData) {
      return <ScriptDisplay scriptData={scriptData} />;
  }

  return (
    <Card className="shadow-lg">
      <CardHeader>
        <div className="flex items-center gap-4">
          <Button
            variant="outline"
            size="icon"
            onClick={onBack}
            className="shrink-0"
          >
            <ArrowLeft className="h-4 w-4" />
            <span className="sr-only">Back</span>
          </Button>
          <div>
            <CardTitle className="font-headline text-3xl">
              Add Sources
            </CardTitle>
            <CardDescription>
              Provide sources for the title: "{selectedTitle}"
            </CardDescription>
          </div>
        </div>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="space-y-2">
            <Label htmlFor="urls" className="text-lg font-semibold font-headline">
              Source URLs
            </Label>
            <Textarea
              id="urls"
              placeholder="https://docs.microsoft.com/...\nhttps://azure.microsoft.com/en-us/blog/..."
              value={urls}
              onChange={(e) => setUrls(e.target.value)}
              rows={4}
              disabled={isLoading}
            />
             <Button onClick={handleAddUrls} disabled={isLoading || !urls.trim()}>
                <Plus className="mr-2" /> Add URLs
            </Button>
          </div>
          <div className="space-y-2">
            <Label className="text-lg font-semibold font-headline">
              Additional Sources
            </Label>
            <div className='flex gap-2'>
                <Button onClick={handlePdfUploadClick} disabled={isLoading} variant="outline">
                    <FileText className="mr-2" /> Add PDF
                </Button>
                <input
                    type="file"
                    ref={fileInputRef}
                    onChange={handleFileChange}
                    className="hidden"
                    accept="application/pdf"
                />
                 <Button onClick={handleAddText} disabled={isLoading} variant="outline">
                    <Text className="mr-2" /> Add Text
                </Button>
            </div>
          </div>
        </div>
        
        {sources.length > 0 && (
          <div>
            <h3 className="font-headline text-xl font-semibold mb-3 border-t pt-6">
              Added Sources
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {sources.map((source) => (
                <div
                  key={source.id}
                  className="flex items-center justify-between p-2 rounded-md border bg-muted/50"
                >
                  <div className="flex items-center gap-2 truncate">
                    {renderSourceIcon(source.type)}
                    <span className="truncate text-sm text-foreground/90">
                      {source.name}
                    </span>
                  </div>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => handleRemoveSource(source.id)}
                    className="shrink-0 h-8 w-8"
                    aria-label="Remove source"
                    disabled={isLoading}
                  >
                    <Trash2 className="h-4 w-4 text-destructive" />
                  </Button>
                </div>
              ))}
            </div>
          </div>
        )}
      </CardContent>
      <CardFooter className="flex justify-end bg-muted/50 p-4 rounded-b-lg">
        <Button onClick={handleGenerateScript} disabled={isLoading || sources.length === 0}>
            {isLoading ? (
                <>
                    <Wand2 className="mr-2 h-5 w-5 animate-spin" />
                    Generating Script...
                </>
            ) : (
                <>
                    <Wand2 className="mr-2 h-5 w-5" />
                    Generate Script
                </>
            )}
        </Button>
      </CardFooter>
    </Card>
  );
}
